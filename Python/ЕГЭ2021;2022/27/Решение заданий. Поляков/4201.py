#(№ 4201) (В. Ярцев) Имеется набор данных, состоящий из троек положительных целых чисел.
#Необходимо выбрать из каждой тройки ровно два числа так,
#чтобы сумма всех выбранных чисел делилась на 3 или на 17, но не делилась на оба этих числа одновременно,
#и при этом была минимально возможной. Гарантируется, что искомую сумму получить можно.
f=open('файлик')#файлик
n=int(f.readline())#кол-во троек

s3=[0]#отдельно для мин сумм с различными остатками от деления на 3
s17=[0]#то де самое, но для 17

for _ in range(n):
    groap=[int(x) for x in f.readline().split()]#сплитуем строку, заносим числа из трйоки в массив
    para=[groap[0]+groap[1],groap[0]+groap[2],groap[1]+groap[2]]#комбинируем пары
    cmb3=[a+b for a in s3 for b in para]#комбинации всех пар с предыдущими числами для 3
    cmb17=[a+b for a in s17 for b in para]#комбинации всех пар с предыдущими числами для 17
    s3={x%3:x for x in sorted(cmb3,reverse=True)}.values()#из сортированного массива в порядке убывания грузим каждый раз меньшее число с разными остатками и отрезаем знач остатка (для 3)
    s17={x%17:x for x in sorted(cmb17,reverse=True)}.values()#то же, но для 17


mins3=[x for x in s3 if ((x%3==0) and (x%17!=0)) or ((x%3==0) and (x%17!=0))]#находим значения, подходящие под условие для 3
mins17=[x for x in s17 if ((x%3==0) and (x%17!=0)) or ((x%3==0) and (x%17!=0))]#то же, для 17

print(min(mins3+mins17))#складываем два массива и находим минимум

