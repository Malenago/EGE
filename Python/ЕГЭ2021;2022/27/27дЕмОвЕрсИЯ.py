############### 1ый Метод ##################

f = open('27_B.txt')
n = int(f.readline())


# https://youtu.be/k6KbLR7vkj4?t=2h17m46s

s, max_s, max_l = 0, 0, 0 # максимальная сумма
min_ps = [float('inf')]*43 # кратна 43, ищем суммы с разн остатками
min_pl  = [0] * 43 # длины сумм из min_ps

for i in range(n): #индексация с нуля
    x = int(f.readline()) #считали число


    s+=x #прибавили к общей сумме
    ost = s % 43 # узнали остаток новой суммы

    
    if ost == 0: # она всегда будет больше пред, т.к. непрерывно прибавляется число Х
        max_s, max_l = s, i+1 # сумма максимальна, индексация с нуля, поэтому +1

        
    else:
        if min_ps[ost] != float('inf'): #если сумма уже есть, т.е. мы ее заносили в массив, берем эти суммы в  if s < min_ps[ost]:  
            m = s - min_ps[ost] # s % 43 - min_ps[s % 43] == 0 всегда, подробнее по ссылке на стрим
            l = i + 1 - min_pl[ost] # не забываем про индексацию

            if (m > max_s) or (m == max_s and l < max_l): #если последовательностей неск, укажите...
                max_s, max_l = m, l  # у этой суммы % 43 == 0 всегда


                
    if s < min_ps[ost]:  # float('inf') - питонская бесконечность
        min_ps[ost], min_pl[ost] = s, i+1  #уменьшаем сумму(массив!!!)

        
print(max_l) #требуют длину, а мы послушные 


############### 2ой Метод #####################

f = open('27_B.txt')
n = int(f.readline())

curr_s = [0]*43 #динамический счет сумм по остаткам
curr_l = [0]*43

max_sum, min_len = 0, 0 #итоговые значения
for _ in range(n):
    x = int(f.readline())

    s = [0]*43 #новый массив, который включает новое число и все пары нового числа+ значения из curr_s
    l = [0]*43

    for i in range(43):
        if curr_s[i] != 0:
            a = curr_s[i] + x #все пары
            if a > s[a % 43]:
                s[a % 43] = a
                l[a % 43] = curr_l[i] + 1 #идексация

    if x > s[x % 43]: # включает новое число
        s[x % 43] = x; l[x % 43] = 1 

    if s[0] > max_sum or (s[0] == max_sum and l[0] < min_len): #читайте внимательно задание
        max_sum, min_len = s[0], l[0]
    

    curr_s = s; curr_l = l; #обновление всех сумм с разными остатками
    
    
print(min_len)
